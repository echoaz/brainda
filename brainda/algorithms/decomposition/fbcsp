# -*- coding: utf-8 -*-
#
# Authors: Swolf & echoaz & ch-MEIJIE
# Date: 2022/8/8
# License: MIT License
"""
Common Spatial Patterns and his happy little buddies!

"""
from copy import deepcopy
from typing import Union, Optional, List, Dict, Tuple
from functools import partial

import numpy as np
from numpy import ndarray
from scipy.linalg import eigh, pinv, solve
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.model_selection import GridSearchCV, StratifiedKFold, ShuffleSplit
from sklearn.feature_selection import SelectKBest, mutual_info_classif
from sklearn.svm import SVC
from sklearn.linear_model import Ridge
from sklearn.multiclass import OneVsRestClassifier, OneVsOneClassifier
from sklearn.pipeline import make_pipeline

from .base import robust_pattern, FilterBank
from ..utils.covariance import nearestPD, covariances

def csp_kernel(X: ndarray, y: ndarray) -> Tuple[ndarray, ndarray, ndarray]:
    """The kernel in CSP algorithm based on paper [1]_.

    Parameters
    ----------
    X: ndarray
        eeg data, shape (n_trials, n_channels, n_samples).
    y: ndarray
        labels of X, shape (n_trials,).

    Returns
    -------
    W: ndarray
        Spatial filters, shape (n_channels, n_filters). n_filters 通常等于n_channels
    D: ndarray
        Eigenvalues of spatial filters, shape (n_filters,).
    A: ndarray
        Spatial patterns, shape (n_channels, n_patterns).

    References
    ----------
    .. [1] Ramoser H, Muller-Gerking J, Pfurtscheller G. Optimal spatial filtering of single trial EEG during imagined hand movement[J]. IEEE transactions on rehabilitation engineering, 2000, 8(4): 441-446.
    """
    X, y = np.copy(X), np.copy(y)
    labels = np.unique(y)
    X = X - np.mean(X, axis=-1, keepdims=True)
    if len(labels) != 2:
        raise ValueError("the current kernel is for 2-class problem.")
    
    C1 = covariances(X[y==labels[0]])
    C2 = covariances(X[y==labels[1]])

    # # trace normalization
    # # this operation equals to trial normalization
    # C1 = C1 / np.trace(C1, axis1=-1, axis2=-2)[:, np.newaxis, np.newaxis]
    # C2 = C2 / np.trace(C2, axis1=-1, axis2=-2)[:, np.newaxis, np.newaxis]

    C1 = np.mean(C1, axis=0)
    C2 = np.mean(C2, axis=0)
    Cc = C1 + C2
    # check positive-definiteness
    Cc = nearestPD(Cc)
    # generalized eigenvalue problem
    D, W = eigh(C1, Cc)
    ix = np.argsort(D)[::-1]
    W = W[:, ix]
    D = D[ix]

    A = robust_pattern(W, C1, W.T@C1@W)

    return W, D, A

def csp_feature(W: ndarray, X: ndarray,
        n_components: int = 2) -> ndarray:
    """Return CSP features in paper [1]_.

    Parameters
    ----------
    W : ndarray
        spatial filters from csp_kernel, shape (n_channels, n_filters)
    X : ndarray
        eeg data, shape (n_trials, n_channels, n_samples)
    n_components : int, optional
        the first k components to use, usually even number, by default 2

    Returns
    -------
    ndarray
        features of shape (n_trials, n_features)  #

    Raises
    ------
    ValueError
        n_components should less than the number of channels

    References
    ----------
    .. [1] Ramoser H, Muller-Gerking J, Pfurtscheller G. Optimal spatial filtering of single trial EEG during imagined hand movement[J]. IEEE transactions on rehabilitation engineering, 2000, 8(4): 441-446.
    """
    W, X = np.copy(W), np.copy(X)
    max_components = W.shape[1]
    if n_components > max_components:
        raise ValueError("n_components should less than the number of channels")
    
    eps = np.finfo(X.dtype).eps#非负最小值
    X = X - np.mean(X, axis=-1, keepdims=True)
    # normalized variance
    features = np.mean(np.square(np.matmul(W[:, :n_components].T, X)), axis=-1)
    features = features / (np.sum(features, axis=-1, keepdims=True) + eps)
    # log-transformation
    features = np.log(np.clip(features, eps, None))#clip截取 小于eps都不变为eps，大于无限制
    return features



def gw_csp_kernel(X: ndarray, y: ndarray,
        ajd_method: str = 'uwedge') -> Tuple[ndarray, ndarray, ndarray, ndarray]:
    """Grosse-Wentrup AJD method based on paper [1]_.

    Parameters
    ----------
    X : ndarray
        eeg data, shape (n_trials, n_channels, n_samples).
    y : ndarray
        labels, shape (n_trials).
    ajd_method : str, optional
        ajd methods, 'uwedge' 'rjd' and 'ajd_pham', by default 'uwedge'.

    Returns
    -------
    W: ndarray
        Spatial filters, shape (n_channels, n_filters).
    D: ndarray
        Eigenvalues of spatial filters, shape (n_filters,).
    A: ndarray
        Spatial patterns, shape (n_channels, n_patterns).
    mutual_info: ndarray
        Mutual informaiton values, shape (n_filters).

    References
    ----------
    .. [1] Grosse-Wentrup, Moritz, and Martin Buss. "Multiclass common spatial patterns and information theoretic feature extraction." Biomedical Engineering, IEEE Transactions on 55, no. 8 (2008): 1991-2000.
    """
    X, y = np.copy(X), np.copy(y)
    labels = np.unique(y)
    X = X - np.mean(X, axis=-1, keepdims=True)

    Cx = []
    for label in labels:
        C = covariances(X[y==label])
        # trace normalization
        C = C / np.trace(C, axis1=-1, axis2=-2)[:, np.newaxis, np.newaxis]
        Cx.append(np.mean(C, axis=0))
    Cx = np.stack(Cx)
    W, D = ajd(Cx, method=ajd_method)
    # Ctot = np.mean(Cx, axis=0)
    # W = W / np.sqrt(np.diag(W.T@Ctot@W))
    W = W / np.sqrt(D)

    # compute mutual information values
    Pc = [np.mean(y == label) for label in labels]
    mutual_info = []
    for j in range(W.shape[-1]):
        a = 0
        b = 0
        for i in range(len(labels)):
            # tmp = np.dot(np.dot(W[j], self.C_[i]), W[j].T)
            tmp = W[:, j].T@Cx[i]@W[:, j]
            a += Pc[i] * np.log(np.sqrt(tmp))
            b += Pc[i] * (tmp ** 2 - 1)
        mi = - (a + (3.0 / 16) * (b ** 2))
        mutual_info.append(mi)
    mutual_info = np.array(mutual_info)
    ix = np.argsort(mutual_info)[::-1]
    W = W[:, ix]
    mutual_info = mutual_info[ix]
    D = D[ix]
    A = robust_pattern(W, Cx[0], W.T@Cx[0]@W)
    return W, D, A, mutual_info


class FBCSP(FilterBank):
    """FBCSP.

    FilterBank CSP based on paper [1]_.
    Parameters
    ----------
    X: ndarray
        eeg data, shape (n_trials, n_channels, n_samples).
    y: ndarray
        labels of X, shape (n_trials,).

    Returns
    -------
    W: ndarray
        Spatial filters, shape (n_channels, n_filters).
    D: ndarray
        Eigenvalues of spatial filters, shape (n_filters,).
    A: ndarray
        Spatial patterns, shape (n_channels, n_patterns).
    References
    ----------
    .. [1] Ang K K, Chin Z Y, Zhang H, et al. Filter bank common spatial pattern (FBCSP) in brain-computer interface[C]//2008 IEEE International Joint Conference on Neural Networks (IEEE World Congress on Computational Intelligence). IEEE, 2008: 2390-2397.
    """
    def __init__(self,
            n_components: Optional[int] = None,
            max_components: Optional[int] = None,
            n_mutualinfo_components: Optional[int] = None,
            filterbank: Optional[List[ndarray]] = None):
        self.n_components = n_components
        self.max_components = max_components
        self.n_mutualinfo_components = n_mutualinfo_components
        self.filterbank = filterbank
        super().__init__(CSP(n_components=n_components, max_components=max_components), filterbank=filterbank)
        #返回空间滤波器w(n_channels, n_filters)，特征向量D(n_filters,);
        #拼接每个频带得到的n_components个特征向量，得到 n_components X 频带数 个特征向量




    def fit(self, X: ndarray, y: ndarray):
        super().fit(X, y)
        features = super().transform(X)
        if self.n_mutualinfo_components is None:
            estimator = make_pipeline(*[
                SelectKBest(score_func=mutual_info_classif, k='all'), 
                SVC()
            ])
            params = {'selectkbest__k': np.arange(1, features.shape[1]+1)}
            
            n_splits = np.min(np.unique(y, return_counts=True)[1])
            n_splits = 5 if n_splits > 5 else n_splits

            gs = GridSearchCV(estimator,
                param_grid=params, scoring='accuracy', 
                cv=StratifiedKFold(n_splits=n_splits, shuffle=True), refit=False, n_jobs=-1, verbose=False)
            gs.fit(features, y)
            self.best_n_mutualinfo_components_ = gs.best_params_['selectkbest__k']
            self.selector_ = SelectKBest(
                score_func=mutual_info_classif, k=self.best_n_mutualinfo_components_)
        else:
            self.selector_ = SelectKBest(
                score_func=mutual_info_classif, k=self.n_mutualinfo_components) 
        self.selector_.fit(features, y)
        return self 
        #基于最大化互信息策略选择得到最优的K个特征
        #互信息：是一个随机变量中包含的关于另一个随机变量的信息量，或者说是一个随机变量由于已知另一个随机变量而减少的不肯定性

    def transform(self, X: ndarray):
        features = super().transform(X)
        features = self.selector_.transform(features)
        return features

class CSP(BaseEstimator, TransformerMixin):
    """Common Spatial Pattern.

    if n_components is None, auto finding the best number of components with gridsearch. The upper searching limit is determined by max_components, default is half of the number of channels.
    """
    def __init__(self,
            n_components: Optional[int] = None,
            max_components: Optional[int] = None):
        self.n_components = n_components
        self.max_components = max_components

    def fit(self, X: ndarray, y: ndarray):
        self.classes_ = np.unique(y)
        self.W_, self.D_, self.A_ = csp_kernel(X, y)
        # resorting with 0.5 threshold
        self.D_ = np.abs(self.D_ - 0.5)
        ind = np.argsort(self.D_, axis=-1)[::-1]
        self.W_, self.D_, self.A_ = self.W_[:, ind], self.D_[ind], self.A_[:, ind]

        # auto-tuning
        if self.n_components is None:
            estimator = make_pipeline(*[CSP(n_components=self.n_components), SVC()])
            if self.max_components is None:
                params = {'csp__n_components': np.arange(1, self.W_.shape[1]+1)}
            else:
                params = {'csp__n_components': np.arange(1, self.max_components+1)}
            
            n_splits = np.min(np.unique(y, return_counts=True)[1])
            n_splits = 5 if n_splits > 5 else n_splits
            
            gs = GridSearchCV(estimator,
                param_grid=params, scoring='accuracy', 
                cv=StratifiedKFold(n_splits=n_splits, shuffle=True), refit=False, n_jobs=-1, verbose=False)
            gs.fit(X, y)
            self.best_n_components_ = gs.best_params_['csp__n_components']
        return self

    def transform(self, X: ndarray):
        n_components = self.best_n_components_ if self.n_components is None else self.n_components
        return csp_feature(self.W_, X, n_components=n_components)

class MultiCSP(BaseEstimator, TransformerMixin):
    def __init__(self,
            n_components: Optional[int] = None,
            max_components: Optional[int] = None,
            multiclass: str = 'ovr', ajd_method: str ='uwedge'):
        self.n_components = n_components
        self.max_components = max_components
        self.multiclass = multiclass
        self.ajd_method = ajd_method

    def fit(self, X: ndarray, y: ndarray):
        self.classes_ = np.unique(y)

        if self.multiclass == 'ovr':
            self.estimator_ = OneVsRestClassifier(
                make_pipeline(*[
                CSP(n_components=self.n_components, max_components=self.max_components), SVC()
                ]), n_jobs=-1)
            self.estimator_.fit(X, y)

        elif self.multiclass == 'ovo':
            self.estimator_ = OneVsOneClassifier(
                make_pipeline(*[
                CSP(n_components=self.n_components, max_components=self.max_components), SVC()
                ]), n_jobs=-1)
            # patching avoiding 2d array check
            self.estimator_._validate_data = partial(self.estimator_._validate_data, allow_nd=True)
            self.estimator_.fit(X, y)

        elif self.multiclass == 'grosse-wentrup':
            self.W_, _, self.A_, self.mutualinfo_values_ = gw_csp_kernel(
                X, y, ajd_method=self.ajd_method)
            if self.n_components is None:
                estimator = make_pipeline(*[
                    MultiCSP(n_components=self.n_components, multiclass='grosse-wentrup', ajd_method=self.ajd_method), SVC()
                ])
                if self.max_components is None:
                    params = {'multicsp__n_components': np.arange(1, self.W_.shape[1]+1)}
                else:
                    params = {'multicsp__n_components': np.arange(1, self.max_components+1)}

                n_splits = np.min(np.unique(y, return_counts=True)[1])
                n_splits = 5 if n_splits > 5 else n_splits
                gs = GridSearchCV(estimator,
                    param_grid=params, scoring='accuracy', 
                    cv=StratifiedKFold(n_splits=n_splits, shuffle=True), refit=False, n_jobs=-1, verbose=False)
                gs.fit(X, y)
                self.best_n_components_ = gs.best_params_['multicsp__n_components']
        else:
            raise ValueError("not a valid multiclass strategy")
        return self

    def transform(self, X: ndarray):
        if self.multiclass == 'grosse-wentrup':
            n_components = self.best_n_components_ if self.n_components is None else self.n_components
            features = csp_feature(self.W_, X, n_components=n_components)
        else:
            features = np.concatenate([est[0].transform(X) for est in self.estimator_.estimators_], axis=-1)
        return features



class FBMultiCSP(FilterBank):
    def __init__(self,
            n_components: Optional[int] = None,
            max_components: Optional[int] = None,
            multiclass: str = 'ovr', ajd_method: str ='uwedge',
            n_mutualinfo_components: Optional[int] = None,
            filterbank: Optional[List[ndarray]] = None):
        self.n_components = n_components
        self.max_components = max_components
        self.multiclass = multiclass
        self.ajd_method = ajd_method
        self.n_mutualinfo_components = n_mutualinfo_components
        self.filterbank = filterbank
        self.n_mutualinfo_components = n_mutualinfo_components
        super().__init__(MultiCSP(n_components=n_components, max_components=max_components, multiclass=multiclass, ajd_method=ajd_method),filterbank=filterbank)

    def fit(self, X: ndarray, y: ndarray):
        super().fit(X, y)
        features = super().transform(X)
        if self.n_mutualinfo_components is None:
            estimator = make_pipeline(*[
                SelectKBest(score_func=mutual_info_classif, k='all'), 
                SVC()
            ])
            params = {'selectkbest__k': np.arange(1, features.shape[1]+1)}

            n_splits = np.min(np.unique(y, return_counts=True)[1])
            n_splits = 5 if n_splits > 5 else n_splits

            gs = GridSearchCV(estimator,
                param_grid=params, scoring='accuracy', 
                cv=StratifiedKFold(n_splits=n_splits, shuffle=True), refit=False, n_jobs=-1, verbose=False)
            gs.fit(features, y)
            self.best_n_mutualinfo_components_ = gs.best_params_['selectkbest__k']
            self.selector_ = SelectKBest(
                score_func=mutual_info_classif, k=self.best_n_mutualinfo_components_)
        else:
            self.selector_ = SelectKBest(
                score_func=mutual_info_classif, k=self.n_mutualinfo_components)
        self.selector_.fit(features, y)
        return self

    def transform(self, X: ndarray):
        features = super().transform(X)
        features = self.selector_.transform(features)
        return features

